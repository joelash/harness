<!DOCTYPE html><html lang="en"><head><title>GUIDE</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="GUIDE"><meta name="groc-project-path" content="GUIDE.md"><meta name="groc-github-url" content="https://github.com/todoubled/todoubled"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/todoubled/todoubled/blob/master/GUIDE.md">GUIDE.md</a></div></div><div id="document"><div class="segment"><div class="comments"><div class="wrapper"><h1 id="guide">Guide</h1>

<h6 id="ageneraltutorialforworkingwithharness">A general tutorial for working with <code>harness</code>.</h6>

<p>Ship HTML, CSS and JavaScript by writing small Mustache, Stylus and CoffeeScript modules with unit and integration test coverage.</p>

<hr />

<p>First, run <code>make install</code> to setup dependencies.
This will install all necessary node packages and tools.</p>

<p><code>harness</code> expects a certain directory structure, some of which is configurable via environment variables.
Feel free to hack <code>harness/build.coffee</code> if you're not happy with the assumed directory structure:</p>

<pre><code> project-repository
 |- harness
   |- build.coffee
 |- app
   |- src
     |- coffeescripts
       |- views
       |- models
       |- index.coffee
       |- helper.coffee
       |- integration.coffee
     |- stylesheets
       |- hello-world.styl
       |- headline.styl
     |- templates
       |- layout.mustache
       |- headline.mustache
     |- vendor
       |- state-machine.js
   |- test
     |- unit
       |- main-app-view.coffee
       |- model.coffee
     |- integration
       |- pageload-behavior.coffee
   |- fixtures
     |- headline-api-response.json
   |- public
     |- index.html
     |- image.png
</code></pre>

<p>You can customize the names of the <code>app</code> and <code>src</code> directories by setting <code>APP_DIR</code> and <code>SOURCE_DIR</code> in <code>harness/env.sh</code>.</p>

<p>Assuming you've got the directory structure explained above, <code>make server</code> will start the development server and file watchers.</p>

<p>In a separate shell, run <code>make test</code> to start the auto-test runner.
Tests in <code>app/test/unit</code> will run every time a file in <code>app/test/unit</code> or <code>app/source</code> changes.</p>

<p>Periodically, run <code>make itest</code> to run the headless integration tests and ensure your UI is behaving as expected.</p>

<hr />

<h2 id="html">HTML</h2>

<p>HTML should be stored in <code>.mustache</code> files kept in <code>app/source/templates</code>.
To use the templates in a CoffeeScript module, require <code>tmplates</code> to use the <code>Template</code> getter object to return the contents of a file in <code>app/source/templates</code>.</p>

<pre><code>Template = require 'tmplates'

# Log the contents of `app/source/templates/hello-world.mustache`.
console.log Template 'hello-world'
</code></pre>

<h2 id="css">CSS</h2>

<p>Stylus is preferred but CSS can also be imported.
There are plans to support any preprocessing step in the future if you want to use Sass or Less.</p>

<h2 id="javascript">JavaScript</h2>

<p>CoffeeScript is preferred but JavaScript can also be <code>require</code>'d. Modules should be small, reusable and written in the <a href="http://www.commonjs.org/">CommonJS</a> format.
Here's some example usage of 2 different modules:</p>

<p><code>app/source/coffeescripts/ui-callbacks.coffee</code>:</p>

<pre><code>{Search} = require '../wrappers/search.coffee'

@onEnterSearch = (event) -&gt;
  new Search {event}
</code></pre>

<p><code>app/source/coffeescripts/event-handlers.coffee</code>:</p>

<pre><code>{onEnterSearch} = require './ui-callbacks.coffee'

$('#search').on 'click', onEnterSearch
</code></pre>

<h2 id="images-and-fonts">Images and Fonts</h2>

<p>Prefix image and font filenames with the prefix defined by <code>PROJECT_PREFIX</code> in <code>harness/env.sh</code> for deployment ease.
Built assets will also use this prefix so that <code>make deploy</code> can just glob <code>app/public/PROJECT_PREFIX*</code>.</p>

<hr />

<h2 id="api-mocks">API Mocks</h2>

<p><code>harness</code> makes it really easy to test your UI against specific data sets returned from an API.
You're free to hit actual remote endpoints if you want, but <code>harness</code> makes it very easy to save and reproduce edge-case API responses locally.
API mocks also make the integration tests fast, because API calls are local to the <code>harness</code> server.</p>

<h2 id="deployment">Deployment</h2>

<p>Deployment is a bit different than in the usual sense. <code>harness</code> can "deploy" to any directory on your local file system.
This makes it very easy to deploy your latest build to another local repo, like a Rails app for example.</p>

<h2 id="integration">Integration</h2>

<p>Since you're now developing outside of the production host app, the goal is to reproduce that environment as identically as possible.
This involves mirroring the instantiation and style override files that need to exist in the host app repo as integration points.</p>

<p>In your <code>harness</code> repo, instantiate and smooth out styles in <code>app/source/coffeescripts/integration.coffee</code> and <code>app/source/stylesheets/integration.styl</code>.</p>

<p>When integrating with the host app repo, create 2 new files for integration points:</p>

<p><strong><code>PROJECT_PREFIX-integration.js</code> file for configuration and instantiation</strong></p>

<ul>
<li>Allows configuration to be passed in from the server</li>
<li>Discourages auto-instantiation</li>
</ul>

<p><strong><code>PROJECT_PREFIX-integration.css</code> file for image and font rules and any necessary style overrides</strong></p>

<ul>
<li>Allows image and font assets to be served up via the production server-side caching strategies</li>
<li>Smooths out style differences post-integration</li>
</ul></div></div></div></div></body></html>